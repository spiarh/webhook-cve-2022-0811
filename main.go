// Based on https://github.com/kubernetes-sigs/controller-runtime/tree/master/examples/builtins

package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"strings"

	corev1 "k8s.io/api/core/v1"
	_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/manager/signals"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

func init() {
	log.SetLogger(zap.New())
}

func main() {
	entryLog := log.Log.WithName("entrypoint")

	// Setup a Manager
	entryLog.Info("setting up manager")
	mgr, err := manager.New(config.GetConfigOrDie(), manager.Options{})
	if err != nil {
		entryLog.Error(err, "unable to set up overall controller manager")
		os.Exit(1)
	}

	// Setup webhooks
	entryLog.Info("setting up webhook server")
	hookServer := mgr.GetWebhookServer()

	entryLog.Info("registering webhooks to the webhook server")
	hookServer.Register("/validate-v1-pod-sysctl", &webhook.Admission{
		Handler: &podValidator{Client: mgr.GetClient()},
	})

	entryLog.Info("starting manager")
	if err := mgr.Start(signals.SetupSignalHandler()); err != nil {
		entryLog.Error(err, "unable to run manager")
		os.Exit(1)
	}
}

// podValidator validates Pods
type podValidator struct {
	Client  client.Client
	decoder *admission.Decoder
}

// podValidator admits a pod if a sysctl setting does not contain "+" or "=" in the value.
func (v *podValidator) Handle(ctx context.Context, req admission.Request) admission.Response {
	pod := &corev1.Pod{}

	err := v.decoder.Decode(req, pod)
	if err != nil {
		return admission.Errored(http.StatusBadRequest, err)
	}

	return validatePod(pod)
}

func validatePod(pod *corev1.Pod) admission.Response {
	secCtx := pod.Spec.SecurityContext
	if secCtx != nil {
		if len(secCtx.Sysctls) == 0 {
			return admission.Allowed("")
		}

		for _, sysctl := range secCtx.Sysctls {
			if strings.Contains(sysctl.Value, "+") {
				return admission.Denied(fmt.Sprintf("Usage of + in sysctl value if forbidden: name=%s, value=%s", sysctl.Name, sysctl.Value))
			}
			if strings.Contains(sysctl.Value, "=") {
				return admission.Denied(fmt.Sprintf("Usage of = in sysctl value if forbidden: name=%s, value=%s", sysctl.Name, sysctl.Value))
			}
		}
	}

	return admission.Allowed("")
}

// podValidator implements admission.DecoderInjector.
// A decoder will be automatically injected.

// InjectDecoder injects the decoder.
func (v *podValidator) InjectDecoder(d *admission.Decoder) error {
	v.decoder = d
	return nil
}
